{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix React error #185 infinite render loop with useCallback",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Add useCallback to React imports in PracticeGamePage.tsx",
      "acceptanceCriteria": [
        "The import statement includes useCallback alongside useState and useEffect"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/apa/PracticeGamePage.tsx",
          "operation": "modify",
          "description": "Add useCallback to the React imports from 'react'. Change the import statement from 'import { useState, useEffect } from \"react\";' to 'import { useState, useEffect, useCallback } from \"react\";'. This prepares the component to use the useCallback hook for memoizing the handleLiveRackUpdate function."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Wrap handleLiveRackUpdate with useCallback and [session] dependency",
      "acceptanceCriteria": [
        "handleLiveRackUpdate is wrapped with useCallback",
        "The dependency array contains [session]",
        "The function body logic remains completely unchanged",
        "The function still performs lag winner remapping and calls setLiveRackPoints"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/apa/PracticeGamePage.tsx",
          "operation": "modify",
          "description": "Wrap the handleLiveRackUpdate function definition with useCallback and add [session] as the dependency array. The wrapper should be: const handleLiveRackUpdate = useCallback((data: { player1Points: number; player2Points: number }) => { /* existing function body unchanged */ }, [session]). This memoizes the function to prevent infinite render loops while maintaining the exact same logic for lag winner remapping and setLiveRackPoints calls. Do not modify any of the function body logic - only add the useCallback wrapper around the existing function."
        }
      ]
    }
  ]
}